# Architecture Decision Records (ADR)

Шаблон для документирования архитектурных решений.

---

## Быстрый старт

1. Скопируйте [adr.md](adr.md):
   ```bash
   cp templates/adr/adr.md docs/adr/ADR-0001-database-choice.md
   ```
2. Заполните секции
3. Сохраните в `docs/adr/`

---

## Что такое ADR?

**Architecture Decision Record (ADR)** - это документ, который фиксирует:
- **Контекст** - почему вообще возникла проблема
- **Варианты** - какие решения рассматривались
- **Решение** - что выбрали и почему
- **Последствия** - что это даёт (положительное и отрицательное)

**Цель:** Сохранить контекст принятия решения для будущих поколений (и себя через год).

---

## Файлы

### [adr.md](adr.md)
**Шаблон для документирования архитектурного решения**

**Структура:**
- Metadata (номер, статус, дата)
- Контекст и проблема
- Рассматриваемые варианты (3+)
- Принятое решение с обоснованием
- C4: Context, Container, Component
- Sequence диаграмма
- Последствия (положительные/отрицательные)
- Альтернативы (почему отклонены)

**Статусы:**
- `Proposed` - предложено, обсуждается
- `Accepted` - принято, реализуется
- `Deprecated` - устарело, но ещё используется
- `Superseded by ADR-XXXX` - заменено другим решением

---

### [adr.en.md](adr.en.md)
**Английская версия шаблона**

Для команд с международным составом или документации на английском.

---

## Когда использовать ADR

### Обязательно документировать

- **Выбор технологии/фреймворка**
  - Пример: PostgreSQL vs MongoDB
  - Пример: gRPC vs REST

- **Изменение архитектурного стиля**
  - Пример: Монолит -> Микросервисы
  - Пример: Event-Driven -> Request-Response

- **Новые архитектурные паттерны**
  - Пример: Внедрение CQRS
  - Пример: Переход на Event Sourcing

- **Решения с trade-offs**
  - Пример: Консистентность vs Доступность (CAP)
  - Пример: Latency vs Throughput

- **Безопасность и compliance**
  - Пример: Выбор метода аутентификации
  - Пример: Стратегия шифрования данных

### Можно не документировать

- Тривиальные выбор (очевидные решения)
- Временные workarounds
- Локальные изменения без глобального влияния
- Выбор библиотек без архитектурного impact

---

## Структура директорий

```
docs/adr/
├── README.md                          # Индекс всех ADR
├── ADR-0001-database-choice.md
├── ADR-0002-api-gateway.md
├── ADR-0003-caching-strategy.md
├── ADR-0004-message-broker.md        # Superseded by ADR-0007
└── ADR-0007-event-streaming.md       # Replaces ADR-0004
```

---

## Именование

```
ADR-NNNN-short-title.md
```

- `NNNN` = 4-значный номер (0001, 0002, ..., 9999)
- `short-title` = краткое описание (kebab-case)

**Примеры:**
```
ADR-0001-database-choice.md
ADR-0002-api-gateway-pattern.md
ADR-0003-distributed-tracing.md
```

---

## Workflow

### Шаг 1: Создание ADR

```bash
# Определите номер (следующий по порядку)
NEXT_ADR=0005

# Скопируйте шаблон
cp templates/adr/adr.md docs/adr/ADR-${NEXT_ADR}-your-decision.md
```

### Шаг 2: Заполнение

**Обязательные секции:**
1. Metadata (номер, статус, дата)
2. Контекст и проблема
3. Рассматриваемые варианты (минимум 3)
4. Принятое решение
5. Последствия

**Опциональные секции:**
- C4 диаграммы
- Sequence диаграммы
- Альтернативы

### Шаг 3: Review

ADR должен пройти review так же, как код:
- Tech Lead
- Архитектор
- Заинтересованные стороны

### Шаг 4: Принятие

После review статус меняется:
```markdown
Status: Accepted
Date: 2026-01-30
```

---

## Обновление ADR

### Когда ADR устаревает

**Вариант 1: Deprecated**
```markdown
Status: Deprecated
Deprecated: 2026-06-30
Reason: Новые требования к производительности
```

**Вариант 2: Superseded**
```markdown
Status: Superseded by ADR-0007
Superseded: 2026-06-30
Reason: Переход на Event Streaming вместо Message Queue
```

### Создание нового ADR

Когда решение меняется - создаём **новый ADR**, а старый помечаем:

```bash
# Новый ADR
cp templates/adr/adr.md docs/adr/ADR-0007-event-streaming.md

# В новом ADR указываем
Replaces: ADR-0004
Reason: Message Queue не справляется с нагрузкой

# В старом ADR обновляем
Status: Superseded by ADR-0007
```

---

## Примеры ADR

### Пример 1: Выбор базы данных

```markdown
# ADR-0001: Выбор PostgreSQL для основного хранилища

Status: Accepted
Date: 2026-01-15

## Контекст и проблема
Нужна реляционная БД для хранения бизнес-данных.
Требования: ACID, SQL, масштабируемость.

## Рассматриваемые варианты

1. PostgreSQL
   - Плюсы: ACID, богатый SQL, JSON, репликация
   - Минусы: сложность настройки масштабирования

2. MySQL
   - Плюсы: простота, популярность
   - Минусы: менее богатый SQL, проблемы с JSON

3. MongoDB
   - Плюсы: гибкая схема, горизонтальное масштабирование
   - Минусы: нет ACID транзакций (в момент выбора)

## Решение
Выбрали PostgreSQL.

Причины:
- Нужны ACID транзакции
- Используем JSON для гибких атрибутов
- Есть опыт в команде

## Последствия

Положительные:
- Строгая консистентность данных
- Богатые возможности SQL
- Поддержка JSON для расширяемости

Отрицательные:
- Сложность горизонтального масштабирования
- Требуется DBA для production
```

---

### Пример 2: Архитектурный паттерн

```markdown
# ADR-0003: Внедрение API Gateway

Status: Accepted
Date: 2026-01-20

## Контекст и проблема
10 микросервисов, клиенты обращаются напрямую к каждому.
Проблемы:
- Дублирование логики аутентификации
- Клиенты знают о внутренней структуре
- Сложно версионировать API

## Рассматриваемые варианты

1. Kong API Gateway
   - Плюсы: богатая функциональность, плагины
   - Минусы: сложность, overhead

2. Envoy Proxy
   - Плюсы: производительность, Service Mesh
   - Минусы: требуется Istio для полноценного использования

3. Custom Gateway на Go
   - Плюсы: полный контроль, минимализм
   - Минусы: нужно поддерживать самим

## Решение
Внедряем Kong API Gateway.

Причины:
- Готовые плагины (auth, rate limiting, logging)
- Масштабируемость
- Не хотим писать свой gateway

## Последствия

Положительные:
- Единая точка входа
- Централизованная аутентификация
- Легко добавлять новые сервисы

Отрицательные:
- Дополнительный hop (latency)
- Single point of failure (митигируем репликацией)
- Нужно изучать Kong
```

---

### Пример 3: Замена решения

```markdown
# ADR-0007: Переход на Kafka для Event Streaming

Status: Accepted
Date: 2026-06-30
Replaces: ADR-0004

## Контекст и проблема
RabbitMQ (из ADR-0004) не справляется с нагрузкой:
- Пиковая нагрузка: 50K msg/sec
- RabbitMQ показывает 10K msg/sec max
- Требуется Event Sourcing

## Рассматриваемые варианты

1. Kafka
   - Плюсы: высокая пропускная способность, event log
   - Минусы: сложность эксплуатации

2. NATS Streaming
   - Плюсы: простота, производительность
   - Минусы: меньше функциональности

3. Оптимизировать RabbitMQ
   - Плюсы: не меняем инфраструктуру
   - Минусы: не решит проблему event sourcing

## Решение
Переходим на Kafka.

Причины:
- Выдерживает > 100K msg/sec
- Event log подходит для Event Sourcing
- Индустриальный стандарт

## Последствия

Положительные:
- Решена проблема производительности
- Возможность Event Sourcing
- Replay событий

Отрицательные:
- Миграция занимает 2 месяца
- Нужен Kafka expertise
- Сложнее в эксплуатации
```

---

## Best Practices

### 1. Документируйте контекст

**Плохо:**
```markdown
## Решение
Выбрали PostgreSQL.
```

**Хорошо:**
```markdown
## Контекст
Нужна БД для заказов. 10K TPS, ACID транзакции критичны.
Команда знает PostgreSQL. Бюджет ограничен.

## Решение
Выбрали PostgreSQL потому что...
```

### 2. Рассматривайте минимум 3 варианта

Показывает, что проблема проанализирована, а не взято первое что попалось.

### 3. Обоснуйте решение

**Плохо:**
```markdown
Выбрали Kafka потому что он популярный.
```

**Хорошо:**
```markdown
Выбрали Kafka потому что:
1. RabbitMQ не справляется (10K vs 50K msg/sec нужных)
2. Нужен event log для Event Sourcing
3. Есть успешные кейсы в индустрии (LinkedIn, Uber)
```

### 4. Опишите последствия честно

Не только положительные, но и **отрицательные**:
- Дополнительная сложность
- Overhead
- Риски
- Технический долг

### 5. Обновляйте статусы

Когда решение устаревает - обновляйте ADR, не удаляйте!

---

## FAQ

**Q: Нужно ли писать ADR для всех решений?**

A: Нет, только для **значимых архитектурных решений** с глобальным влиянием.

**Q: Кто пишет ADR?**

A: Обычно архитектор или Tech Lead. Но может любой член команды.

**Q: Кто принимает решение?**

A: Зависит от организации. Обычно Tech Lead + Архитектор. Иногда нужно согласование с CTO.

**Q: Что делать с устаревшими ADR?**

A: Не удалять! Обновить статус на `Deprecated` или `Superseded by ADR-XXXX`.

**Q: Нужны ли диаграммы в ADR?**

A: Желательно, но не обязательно. Если решение сложное - диаграммы помогают.

**Q: Можно ли менять принятый ADR?**

A: Нет. Создайте новый ADR который заменяет старый (`Superseded`).

---

## Индекс ADR (README.md в docs/adr/)

В `docs/adr/README.md` поддерживайте индекс всех ADR:

```markdown
# Architecture Decision Records

## Active

| # | Title | Date | Status |
|---|-------|------|--------|
| 0007 | Event Streaming with Kafka | 2026-06-30 | Accepted |
| 0003 | API Gateway Pattern | 2026-01-20 | Accepted |
| 0001 | PostgreSQL Database | 2026-01-15 | Accepted |

## Superseded

| # | Title | Date | Superseded By |
|---|-------|------|---------------|
| 0004 | RabbitMQ Message Broker | 2026-01-18 | ADR-0007 |

## Deprecated

| # | Title | Date | Reason |
|---|-------|------|--------|
| 0002 | MongoDB for Logging | 2026-01-16 | Moved to ELK |
```

---

## Связанные ресурсы

**Методология:**
- [ADR GitHub Organization](https://adr.github.io/)
- [Documenting Architecture Decisions](https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions)
- [Michael Nygard's ADR article](https://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions)

**Инструменты:**
- [adr-tools](https://github.com/npryce/adr-tools) - CLI для управления ADR
- [log4brains](https://github.com/thomvaill/log4brains) - ADR visualization

**Книги:**
- Fundamentals of Software Architecture (Richards, Ford)
- Building Evolutionary Architectures (Ford, Parsons, Kua)

---

*Шаблон создан на основе практики Michael Nygard и индустриальных стандартов документирования архитектурных решений.*
